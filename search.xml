<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>匿名飞控源码解析(一)---主程序</title>
      <link href="/2022/02/03/ano/"/>
      <url>/2022/02/03/ano/</url>
      
        <content type="html"><![CDATA[<h1 id="匿名飞控源码研究"><a href="#匿名飞控源码研究" class="headerlink" title="匿名飞控源码研究"></a>匿名飞控源码研究</h1><p>对于这个飞控的研究始于我本科时期的毕业设计，代码上的注释几乎都是由我当时书写，最近准备北航的研究生复试听闻老师们最爱问关于毕业设计的问题，故旧事重提，重新研究一下匿名飞控。<br><br>回想当时的研究，要是要我提出一个匿名飞控的特点即和其他飞控的不同之处就是没有采用硬件中断来做时分复用，而是<em><strong>采用简单的延时程序来做的时分复用</strong></em>，这使得其代码难度降低，不过感觉也有利有弊，长时间不使用定时器中断搞我的现在都有点忘了，不过这些硬件的调用就等到之后研究全权老师的rfly或者我的另一个平衡自行车项目的时候再复健吧。</p><h2 id="从主程序入手"><a href="#从主程序入手" class="headerlink" title="从主程序入手"></a>从主程序入手</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;include.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_FcData.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  USE_FULL_ASSERT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert_failed</span><span class="params">(<span class="keyword">uint8_t</span>* file, <span class="keyword">uint32_t</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当系统出错后，会进入这个死循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//=======================================================================================</span></span><br><span class="line"><span class="comment">//=======================================================================================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">flag.start_ok = All_Init();<span class="comment">//进行所有设备的初始化，并将初始化结果保存</span></span><br><span class="line">Scheduler_Setup();<span class="comment">//调度器初始化，系统为裸奔，这里人工做了一个时分调度器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Scheduler_Run();<span class="comment">//运行任务调度器，所有系统功能，除了中断服务函数，都在任务调度器内完成</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-c主程序分析"><a href="#main-c主程序分析" class="headerlink" title="main.c主程序分析"></a><code>main.c</code>主程序分析<br></h2><h3 id="预处理指令部分"><a href="#预处理指令部分" class="headerlink" title="预处理指令部分"></a>预处理指令部分</h3><p>第一条代码<code>#include &quot;include.h&quot;</code>主程序包含<code>include.h</code>头文件，接下来分部分分析该文件.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INCLUDE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INCLUDE_H_</span></span><br><span class="line">;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>条件编译的经典格式,防止重复包含头文件。</p><hr><p>接下来是头文件的包含，包括硬件驱动程序头文件(一般文件名以DRV开头)，各类数据处理控制算法等程序头文件(一般以Ano开头)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &quot;stm32f4xx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_FcData.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_Scheduler.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BSP_Init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_DT.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_Parameter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_USB.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Drv_time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Drv_pwm_in.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Drv_usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Drv_Gps.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>其中<code>Ano_FcData.h</code>为飞控数据处理的头文件，<code>Ano_Scheduler.h</code>为时分复用系统的头文件，’BSP_Init.h’为飞控初始化程序头文件，’Ano_DT.h’为飞控数据传输程序头文件，<code>Ano_Parameter.h</code>为控制参数配置头文件，<code>Ano_USB.h</code>为USB通信相关头文件。</p><p><code>Drv_time.h</code>为时钟驱动头文件<code>Drv_pwm_in.h</code>为硬件PWM驱动头文件<code>Drv_usart.h</code>为USART通信驱动头文件<code>Drv_Gps.h</code>为GPS驱动头文件。</p><p>以上仅仅是让自己脑子有个大致的印象，以后深入到源码中还会细品各程序。不过在此我还想提醒一下自己包含这么多头文件有什么作用，引用一下&lt;&lt;C程序设计现代方法&gt;&gt;上的目录:<br></p><ul><li>共享宏定义和类型定义</li><li>共享函数原型</li><li>共享变量声明</li></ul><hr><p>接下来是第二条代码<code>#include &quot;Ano_FcData.h&quot;</code>在主程序中包含<code>Ano_FcData.h</code>但是讲道理这个在上一条中已经包含过虽然有条件编译并不会有什么问题，但是其实我认为是多此一举的。由于现在是在分析主程序就并不在本篇中对其他文件的细节进行解读了。</p><h3 id="条件编译部分"><a href="#条件编译部分" class="headerlink" title="条件编译部分"></a>条件编译部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  USE_FULL_ASSERT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert_failed</span><span class="params">(<span class="keyword">uint8_t</span>* file, <span class="keyword">uint32_t</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当系统出错后，会进入这个死循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>由于这部分内容后面不会再涉及并且并不困难故在此处说一下，转到定义处代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_FULL_ASSERT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exported macro ------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  USE_FULL_ASSERT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  The assert_param macro is used for function&#x27;s parameters check.</span></span><br><span class="line"><span class="comment">  * @param  expr: If expr is false, it calls assert_failed function</span></span><br><span class="line"><span class="comment">  *   which reports the name of the source file and the source</span></span><br><span class="line"><span class="comment">  *   line number of the call that failed.</span></span><br><span class="line"><span class="comment">  *   If expr is true, it returns no value.</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))</span></span><br><span class="line"><span class="comment">/* Exported functions ------------------------------------------------------- */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">assert_failed</span><span class="params">(<span class="keyword">uint8_t</span>* file, <span class="keyword">uint32_t</span> line)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> assert_param(expr) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_FULL_ASSERT */</span></span></span><br></pre></td></tr></table></figure><p>宏<code>USE_FULL_ASSERT</code>被定义为常数1，这意味着一旦<code>USE_FULL_ASSERT</code>被定义就会进入到条件编译中，条件编译内容为一个带参数的宏。此处引用一下&lt;&lt;C程序设计现代方法&gt;&gt;上对于带参数的宏的介绍:<br></p><blockquote><p>格式为: #define 标识符(y1,y2,…,yn) 替换列表(x1,x2,…,xn)<br><br>注意:<br></p><ul><li>宏的名字和左括号之间必须没有空格，例如一定是yz_K(_yzk)指的是下划线之间部分无空格</li><li>宏的参数可以在替换列表中根据需要任意引用</li><li>一定注意要多使用括号不然傻瓜替换会治好你的低血压</li></ul></blockquote><p><code>assert_param()</code>此处被封装为一个函数，函数名直译为参数判断，@brief:函数用于函数参数检查，@param:如果参数expr为0调用<code>assert_failed()</code>，这个函数会报道导致失败的文件名和行数；如果expr为1则返回空。并且还会在主函数中定义<code>assert_failed()</code>为死循环。<br><br>而若<code>USE_FULL_ASSERT</code>未被定义则<code>#define assert_param(expr) ((void)0)</code>即返回空值。<br><br>综上，条件编译部分的经典条件编译语句我认为可以去掉而毫无影响，主体部分定义了一个死循环使得当系统出错时进入死循环仅此而已。</p><h3 id="主函数部分"><a href="#主函数部分" class="headerlink" title="主函数部分"></a>主函数部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">flag.start_ok = All_Init();<span class="comment">//进行所有设备的初始化，并将初始化结果保存</span></span><br><span class="line">Scheduler_Setup();<span class="comment">//调度器初始化，系统为裸奔，这里人工做了一个时分调度器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Scheduler_Run();<span class="comment">//运行任务调度器，所有系统功能，除了中断服务函数，都在任务调度器内完成</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数中各函数作用都在当年程序注释中注明，以下复制粘贴一下:<br></p><ul><li><code>flag.start_ok = All_Init();</code>进行所有设备的初始化，并将初始化结果保存</li><li><code>Scheduler_Setup();</code>进调度器初始化，系统为裸奔，这里人工做了一个时分调度器</li><li><code>Scheduler_Run();</code>运行任务调度器，所有系统功能，除了中断服务函数，都在任务调度器内完成</li></ul><p>OK!主程序就看到这儿了，下次和兄弟们一起看<code>Ano_FcData.h</code>和<code>Ano_FcData.c</code>中的数据处理是如何进行的!</p>]]></content>
      
      
      <categories>
          
          <category> 飞控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建备忘录</title>
      <link href="/2022/01/31/hexoLearn/"/>
      <url>/2022/01/31/hexoLearn/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><ul><li><code>hexo s</code>在本地服务器预览一般为<a href="https://localhost:4000/">https://localhost:4000</a><br></li><li><code>hexo n &quot;文件名&quot;</code>新建博文<br></li><li><code>hexo g</code>生成<br></li><li><code>hexo d</code>部署到github或者gitee设置方式见于_config.yml文档<br></li><li><code>hexo clean</code>清理</li></ul><h2 id="hexo主题更换"><a href="#hexo主题更换" class="headerlink" title="hexo主题更换"></a>hexo主题更换</h2><p>在相应github仓库下找到教程一般在blog目录下使用<code>clone</code>指令然后在_config.yml文件中修改theme后名称为相应文件夹名称.</p><h2 id="数学公式采用KaTeX"><a href="#数学公式采用KaTeX" class="headerlink" title="数学公式采用KaTeX"></a>数学公式采用KaTeX</h2>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/31/hello-world/"/>
      <url>/2022/01/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
