<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/02/14/standardVerilog/"/>
      <url>/2022/02/14/standardVerilog/</url>
      
        <content type="html"><![CDATA[<h1 id="verilog编程规范"><a href="#verilog编程规范" class="headerlink" title="verilog编程规范"></a>verilog编程规范</h1><h2 id="工程组织形式"><a href="#工程组织形式" class="headerlink" title="工程组织形式"></a>工程组织形式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XX工程</span><br><span class="line">    |--doc  一般存放工程相关的文档，包括该项目用到的datasheet（数据手册）、设计方案等</span><br><span class="line">    |--par  主要存放工程文件</span><br><span class="line">    |--rtl  主要存放工程的rtl代码，这是工程的核心，文件名与module名称应当一致</span><br><span class="line">    |--sim  主要存放工程的仿真代码</span><br></pre></td></tr></table></figure><h2 id="输入输出定义"><a href="#输入输出定义" class="headerlink" title="输入输出定义"></a>输入输出定义</h2><ol><li>一行只定义一个信号</li><li>信号全部对齐</li><li>同一组的信号放在一起<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> led( </span><br><span class="line">    <span class="keyword">input</span>               sys_clk  ,  <span class="comment">//系统时钟 </span></span><br><span class="line">    <span class="keyword">input</span>               sys_rst_n,  <span class="comment">//系统复位，低电平有效 </span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]  led         <span class="comment">//4位LED灯 </span></span><br><span class="line">    ); </span><br></pre></td></tr></table></figure></li></ol><h2 id="parameter定义"><a href="#parameter定义" class="headerlink" title="parameter定义"></a>parameter定义</h2><ol><li>将parameter定义放在紧跟着module的输入输出定义之后</li><li>命名全部使用大写</li></ol><h2 id="wire-reg定义"><a href="#wire-reg定义" class="headerlink" title="wire/reg定义"></a>wire/reg定义</h2><ol><li>将reg与wire的定义放在紧跟着parameter之后</li><li>建议具有相同功能的信号集中放在一起</li><li>信号需要对齐</li><li>信号需要对齐</li><li>一行只定义一个信号</li></ol><h2 id="信号命名"><a href="#信号命名" class="headerlink" title="信号命名"></a>信号命名</h2><ol><li>内部信号全部使用小写</li><li>模块名字使用小写</li><li>低电平有效的信号，使用_n作为信号后缀</li><li>异步信号，使用_a作为信号后缀</li><li>纯延迟打拍信号使用_dly作为后缀</li></ol><h2 id="always块描述方式"><a href="#always块描述方式" class="headerlink" title="always块描述方式"></a>always块描述方式</h2><ol><li>一个always需要配一个<code>begin</code>和<code>end</code>，<code>beign</code>建议和<code>always</code>放在同一行</li><li>时钟复位触发描述使用<code>posedge sys_clk</code>和<code>negedge sys_rst_n</code></li><li>一个always块只包含一个时钟和复位</li><li>时序逻辑使用非阻塞赋值</li></ol><h2 id="assign块"><a href="#assign块" class="headerlink" title="assign块"></a>assign块</h2><ol><li>assign的逻辑不能太复杂，否则易读性不好</li><li>组合逻辑使用阻塞赋值</li></ol><h2 id="模块例化"><a href="#模块例化" class="headerlink" title="模块例化"></a>模块例化</h2><ol><li>moudle模块例化使用u_xx表示</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>不使用repeat等循环语句</li><li>RTL级别代码里面不使用initial语句，仿真代码除外</li><li>避免产生Latch锁存器，比如组合逻辑里面的if不带else分支、case缺少default语句</li><li>避免使用太复杂和少见的语法，可能造成语法综合器优化力度较低</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>verilog语法二---进阶篇</title>
      <link href="/2022/02/13/DeeperVerilog-md/"/>
      <url>/2022/02/13/DeeperVerilog-md/</url>
      
        <content type="html"><![CDATA[<h1>verilog语法二—进阶篇</h1><h2 id="过程赋值">过程赋值</h2><p>过程赋值用于在<code>initial</code>和<code>always</code>语句块中进行赋值，有阻塞赋值和非阻塞赋值两种。<br><br><em><strong>过程赋值与连续赋值的区别</strong></em>：</p><ul><li>连续性赋值总是处于激活状态，任何操作数的改变都会影响表达式的结果</li><li>过程赋值只有在语句执行的时候，才会起作用</li></ul><h3 id="阻塞赋值">阻塞赋值<code>=</code></h3><ul><li>阻塞指在一个always块中，后面的语句会受到前语句的影响，在同一个always中，一条阻塞赋值语句如果没有执行结束，那么该语句后面的语句就不能被执行，即被“阻塞”。简言之，<em><strong>语句块内顺序执行</strong></em>。</li></ul><p>例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span><span class="comment">//clk上升沿触发或rst_n下降沿触发</span></span><br><span class="line">    <span class="keyword">if</span>(!rst_n)<span class="keyword">begin</span><span class="comment">//rst_n低有效</span></span><br><span class="line">        a=<span class="number">1</span>;</span><br><span class="line">        b=<span class="number">2</span>;</span><br><span class="line">        c=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span><span class="comment">//rst_n高有效</span></span><br><span class="line">        a=<span class="number">0</span>;</span><br><span class="line">        b=a;</span><br><span class="line">        c=b; </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="非阻塞赋值">非阻塞赋值<code>&lt;=</code></h3><ul><li>并行执行语句</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> test ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]   ai, bi ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]   ai2, bi2 ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]   value_blk ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]   value_non ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]   value_non2 ;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        ai            = <span class="number">4&#x27;d1</span> ;   <span class="comment">//(1)</span></span><br><span class="line">        bi            = <span class="number">4&#x27;d2</span> ;   <span class="comment">//(2)</span></span><br><span class="line">        ai2           = <span class="number">4&#x27;d7</span> ;   <span class="comment">//(3)</span></span><br><span class="line">        bi2           = <span class="number">4&#x27;d8</span> ;   <span class="comment">//(4)</span></span><br><span class="line">        #<span class="number">20</span> ;                    <span class="comment">//(5)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//non-block-assigment with block-assignment</span></span><br><span class="line">        ai            = <span class="number">4&#x27;d3</span> ;     <span class="comment">//(6)</span></span><br><span class="line">        bi            = <span class="number">4&#x27;d4</span> ;     <span class="comment">//(7)</span></span><br><span class="line">        value_blk     = ai + bi ;  <span class="comment">//(8)</span></span><br><span class="line">        value_non     &lt;= ai + bi ; <span class="comment">//(9)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//non-block-assigment itself</span></span><br><span class="line">        ai2           &lt;= <span class="number">4&#x27;d5</span> ;           <span class="comment">//(10)</span></span><br><span class="line">        bi2           &lt;= <span class="number">4&#x27;d6</span> ;           <span class="comment">//(11)</span></span><br><span class="line">        value_non2    &lt;= ai2 + bi2 ;      <span class="comment">//(12)</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//stop the simulation</span></span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">10</span> ;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">$time</span> &gt;= <span class="number">1000</span>) <span class="built_in">$finish</span> ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>语句（1）-（8）都是阻塞赋值，按照顺序执行。</li><li>语句（9）-（12）都是非阻塞赋值，并行执行。但是执行顺序也是在（8）之后.</li></ul><h3 id="assign和always的区别">assign和always的区别</h3><ul><li><code>assign</code>不可以带时钟，<code>always</code>可以带时钟，当always不带时钟时与assign逻辑功能完全一致。<code>assign</code>，<code>always</code>和<code>always@(*)</code>用于组合逻辑。</li><li><code>assign</code>之后不能加块，实现组合逻辑只能逐句使用<code>assign</code></li><li>被<code>assign</code>赋值的信号为<code>wire</code>型，在<code>always</code>块下被赋值的信号为<code>reg</code>类型，但此处并非真正的触发器只有带上敏感列表才会被综合成触发器。</li></ul><h3 id="latch（锁存器）和FF（触发器）">latch（锁存器）和FF（触发器）</h3><ul><li>锁存器（Latch），是电平触发的存储单元，数据存储的动作取决于输入时钟（或者使能）信号的电平值。仅当锁存器处于使能状态时，输出才会随着数据输入发生变化。</li><li>触发器（flip-flop），是边沿敏感的存储单元，数据存储的动作（状态转换）由某一信号的上升沿或者下降沿进行同步的。</li></ul><p>引入一个概念latch会产生危害尽量在电路中不要引入latch，原因主要有：</p><ol><li>输入状态可能多次变化，容易产生毛刺，增加了下一级电路的不确定性；</li><li>在大部分 FPGA 的资源中，可能需要比触发器更多的资源去实现 Latch 结构；</li><li>锁存器的出现使得静态时序分析变得更加复杂。</li></ol><p>出现latch情况：</p><ul><li>不带时钟的always语句if、case语句不完整才会产生latch，不过注意带时钟的语句if或者case语句不完整描述不会产生latch。</li></ul><h2 id="状态机（FSM有限状态机）">状态机（FSM有限状态机）</h2><p>根据输出是否与输入有关可以分为：</p><ol><li>moore(摩尔)型状态机，输出与当前无关，可以通过摩尔庄园没人玩了来联想记忆。</li><li>mealy(米粒)型状态机，输出与当前有关。<br>根据状态机的实际写法，可以分为：</li><li>一段式</li><li>二段式</li><li>三段式（推荐方式）：<ol><li>第一段，时序逻辑，非阻塞赋值，传递寄存器的状态；<br>第一个always语句实现同步状态跳转</li><li>第二段，组合逻辑，阻塞赋值，根据当前状态和当前输入，确定下一个状态机的状态；<br>第二个always语句采用组合逻辑判断状态转移条件；</li><li>第三段，时序逻辑，非阻塞赋值，因为是 Mealy 型状态机，根据当前状态和当前输入，确定输出信号；<br>第三个always语句描述状态输出(可以用组合电路输出，也可以时序电路输出)。</li></ol></li></ol><p>使用示例：<br><br>第一步：画出状态转移图</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> S0 = <span class="number">7&#x27;b0000001</span>;  </span><br><span class="line"><span class="keyword">parameter</span> S1 = <span class="number">7&#x27;b0000010</span>; </span><br><span class="line"><span class="keyword">parameter</span> S2 = <span class="number">7&#x27;b0000100</span>; </span><br><span class="line"><span class="keyword">parameter</span> S3 = <span class="number">7&#x27;b0001000</span>; </span><br><span class="line"><span class="keyword">parameter</span> S4 = <span class="number">7&#x27;b0010000</span>; </span><br><span class="line"><span class="keyword">parameter</span> S5 = <span class="number">7&#x27;b0100000</span>; </span><br><span class="line"><span class="keyword">parameter</span> S6 = <span class="number">7&#x27;b1000000</span>;   </span><br></pre></td></tr></table></figure><p>这里对于状态使用的是One-hot码，在数电的学习中一般使用的一般就是正常二进制数。由于采用7位One-hot码所以采用两个7位的寄存器来存储当前状态和下个状态。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>  [<span class="number">6</span>:<span class="number">0</span>]   curr_st     ;     </span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">6</span>:<span class="number">0</span>]   next_st     ;     </span><br></pre></td></tr></table></figure><p>第二步：开始编写三段式状态机代码<br><br>代码中首先是模块声明</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> divider7_fsm (  </span><br><span class="line">    <span class="keyword">input</span>       sys_clk      , <span class="comment">//系统时钟 </span></span><br><span class="line">    <span class="keyword">input</span>       sys_rst_n    , <span class="comment">//系统复位</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span>  clk_divide_7  <span class="comment">//输出时钟</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>然后是之前第一步确定的状态</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> S0 = <span class="number">7&#x27;b0000001</span>;  </span><br><span class="line"><span class="keyword">parameter</span> S1 = <span class="number">7&#x27;b0000010</span>; </span><br><span class="line"><span class="keyword">parameter</span> S2 = <span class="number">7&#x27;b0000100</span>; </span><br><span class="line"><span class="keyword">parameter</span> S3 = <span class="number">7&#x27;b0001000</span>; </span><br><span class="line"><span class="keyword">parameter</span> S4 = <span class="number">7&#x27;b0010000</span>; </span><br><span class="line"><span class="keyword">parameter</span> S5 = <span class="number">7&#x27;b0100000</span>; </span><br><span class="line"><span class="keyword">parameter</span> S6 = <span class="number">7&#x27;b1000000</span>;   </span><br></pre></td></tr></table></figure><p>开始状态机的第一段代码，状态机的第一段<em><strong>采用同步时序描述状态转移</strong></em>。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span>  </span><br><span class="line">        <span class="keyword">if</span> (!sys_rst_n) </span><br><span class="line">            curr_st &lt;= S0; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            curr_st &lt;= next_st; </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure><p><code>sys_clk</code>上升沿并且<code>sys_rst_n</code>无效时，变到下一个状态。<br>然后是状态机的第二段代码，状态机的第二段<em><strong>采用组合逻辑判断状态转移条件</strong></em></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span>  </span><br><span class="line">    <span class="keyword">case</span> (curr_st)  </span><br><span class="line">        S0: next_st = S1; </span><br><span class="line">        S1: next_st = S2; </span><br><span class="line">        S2: next_st = S3; </span><br><span class="line">        S3: next_st = S4; </span><br><span class="line">        S4: next_st = S5; </span><br><span class="line">        S5: next_st = S6; </span><br><span class="line">        S6: next_st = S0; </span><br><span class="line">        <span class="keyword">default</span>: next_st = S0; </span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure><p>再然后是状态机的第三段代码，状态机的第三段描述状态输出(这里采用时序电路输出)</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span>  </span><br><span class="line">    <span class="keyword">if</span> (!sys_rst_n) </span><br><span class="line">        clk_divide_7 &lt;= <span class="number">1&#x27;b0</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((curr_st == S0) | (curr_st == S1) | (curr_st == S2)  | (curr_st == S3))  </span><br><span class="line">        clk_divide_7  &lt;= <span class="number">1&#x27;b0</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((curr_st == S4) | (curr_st == S5) | (curr_st == S6))  </span><br><span class="line">        clk_divide_7  &lt;= <span class="number">1&#x27;b1</span>;    </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        ;  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>意义上代码描述的输出：</p><ul><li>当<code>sys_rst_n</code>有效时，输出时钟信号为低电平</li><li>当<code>sys_rst_n</code>无效时，前四个状态输出低，后三个状态输出低</li></ul><p>很容易发现此时输出时钟的一个周期为7个系统时钟的周期，即七分频。</p><h2 id="模块化设计">模块化设计</h2><p>提出几个概念：</p><ol><li>自顶向下的设计方式：可以把系统划分成几个功能模块，每个功能模块再划分成下一层的子模块</li><li>例化：在一个模块中引用另一个模块，对其端口进行相关连接，叫做模块例化。模块例化建立了描述的层次。信号端口可以通过位置或名称关联，端口连接也必须遵循一些规则。在顶层设计一般只做例化。</li></ol><p>请看如下例子：设计结构如下</p><ol><li>顶层<ol><li>计时器模块</li><li>数码管静态显示模块</li></ol></li></ol><p>在代码上的体现：</p><ol><li>计时器模块</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> time_count( </span><br><span class="line">    <span class="keyword">input</span>           clk     ,   <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span>           rst_n   ,   <span class="comment">// 复位信号 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span>   <span class="keyword">reg</span>    flag        <span class="comment">// 一个时钟周期的脉冲信号 </span></span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="comment">//parameter define </span></span><br><span class="line"><span class="keyword">parameter</span>  MAX_NUM = <span class="number">25000_000</span>; <span class="comment">// 计数器最大计数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他代码省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ol start="2"><li>数码管静态显示模块</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> seg_led_static ( </span><br><span class="line">    <span class="keyword">input</span>               clk     ,   <span class="comment">// 时钟信号 </span></span><br><span class="line">    <span class="keyword">input</span>               rst_n   ,   <span class="comment">// 复位信号（低有效） </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span>               add_flag,   <span class="comment">// 数码管变化的通知信号 </span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">reg</span>  [<span class="number">5</span>:<span class="number">0</span>]  sel     ,   <span class="comment">// 数码管位选 </span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>]  seg_led     <span class="comment">// 数码管段选 </span></span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="comment">//其他代码省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ol start="3"><li>顶层模块</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> seg_led_static_top ( </span><br><span class="line">    <span class="keyword">input</span>               sys_clk  ,       <span class="comment">// 系统时钟 </span></span><br><span class="line">    <span class="keyword">input</span>               sys_rst_n,       <span class="comment">// 系统复位信号（低有效） </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span>    [<span class="number">5</span>:<span class="number">0</span>]     sel      ,       <span class="comment">// 数码管位选 </span></span><br><span class="line">    <span class="keyword">output</span>    [<span class="number">7</span>:<span class="number">0</span>]     seg_led          <span class="comment">// 数码管段选 </span></span><br><span class="line"></span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//parameter define </span></span><br><span class="line"><span class="keyword">parameter</span>  TIME_SHOW = <span class="number">25&#x27;d25000_000</span>;    <span class="comment">// 数码管变化的时间间隔0.5s </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//wire define </span></span><br><span class="line"><span class="keyword">wire</span>       add_flag;                     <span class="comment">// 数码管变化的通知信号 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************************************** </span></span><br><span class="line"><span class="comment">//**                    main code </span></span><br><span class="line"><span class="comment">//***************************************************** </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例化计时模块 </span></span><br><span class="line">time_count #( </span><br><span class="line">    <span class="variable">.MAX_NUM</span>    (TIME_SHOW) </span><br><span class="line">) u_time_count( </span><br><span class="line">    <span class="variable">.clk</span>        (sys_clk  ), </span><br><span class="line">    <span class="variable">.rst_n</span>      (sys_rst_n), </span><br><span class="line">    </span><br><span class="line">    <span class="variable">.flag</span>       (add_flag ) </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="comment">//例化数码管静态显示模块 </span></span><br><span class="line">seg_led_static u_seg_led_static ( </span><br><span class="line">    <span class="variable">.clk</span>        (sys_clk  ),  </span><br><span class="line">    <span class="variable">.rst_n</span>      (sys_rst_n), </span><br><span class="line"></span><br><span class="line">    <span class="variable">.add_flag</span>   (add_flag ),  </span><br><span class="line">    <span class="variable">.sel</span>        (sel      ), </span><br><span class="line">    <span class="variable">.seg_led</span>    (seg_led  ) </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>子模块例化方法<br><img src="/2022/02/13/DeeperVerilog-md/moduleInstantiation.png" alt="子模块例化方法"><br><br>子模块参数例化方法<br><br><img src="/2022/02/13/DeeperVerilog-md/parameterInstantiation.png" alt="子模块参数例化方法"><br>OK！这就是这次的进阶篇了，下篇要介绍的是Verilog编程规范。</p>]]></content>
      
      
      <categories>
          
          <category> verilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Verilog 语法复习笔记（一）</title>
      <link href="/2022/02/12/LearnVerilog-md/"/>
      <url>/2022/02/12/LearnVerilog-md/</url>
      
        <content type="html"><![CDATA[<h1>Verilog 语法复习笔记（一）</h1><h2 id="逻辑值">逻辑值</h2><ul><li>0: 低电平</li><li>1: 高电平</li><li>X：未知(可能为高电平也可能为低电平)</li><li>Z: 高阻态(对外部相当于断开)</li></ul><hr><h2 id="标识符">标识符</h2><h3 id="命名规则">命名规则</h3><ol><li>字母、数字、$、_</li><li>首字符必须为字母或者下划线</li><li>区分大小写</li></ol><h3 id="规范建议">规范建议</h3><ol><li>使用有意义的名字</li><li>采用一些前后缀比如：<ul><li>时钟采用<code>clk</code>前缀：<code>clk_50m</code>，<code>clk_cpu</code></li><li>低电平采用_n后缀：<code>enable_n</code></li></ul></li><li>对于特殊重要的信号采用统一缩写，如<code>rst</code></li><li>同意信号在不同层次要保持一致</li><li>参数统一大写</li></ol><h3 id="数字">数字</h3><ol><li>默认形式为32位十进制</li><li><ul><li>4’b0101表示4位二进制数0101</li><li>4’d2表示4位十进制数字2</li><li>4’ha表示4位十六进制数字a</li></ul></li></ol><p>疑问：此处所指的位数是本进制数字的位数，还是二进制数字的位数？</p><h3 id="数据类型"><em><strong>数据类型</strong></em></h3><p>主要分为三大数据类型：</p><ul><li>寄存器类型</li><li>线网类型</li><li>参数类型</li></ul><h4 id="寄存器类型">寄存器类型</h4><p>含义：表示一个抽象的数据存储单元<br></p><p>注意点：</p><ol><li>只能在always语句和initial语句中被赋值</li><li>默认值为X</li><li>若过程语句描述的是时序逻辑，则寄存器变量为寄存器；而若描述的是组合逻辑，则寄存器变量为对应的硬件连线。</li></ol><p>常见寄存器数据类型:<code>reg</code>,<code>integer</code>,<code>real</code>等</p><p>疑问：过程语句？</p><h4 id="线网类型">线网类型</h4><p>含义：表示verilog结构化原件间的物理连线。</p><p>注意点：</p><ol><li>线网类型的值由驱动元件的值决定</li><li>默认值为Z</li></ol><p>常见线网类型：<code>wire</code>,<code>tri</code>等</p><h4 id="参数类型">参数类型</h4><p>含义：常量</p><p>注意点：</p><ol><li>参数的定义是局部的，只在当前模块下有效。</li><li>关键字<code>parameter</code></li></ol><h3 id="运算符">运算符</h3><p>按功能可以分为7类运算符：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>条件运算符</li><li>位运算符</li><li>拼接运算符</li></ul><h4 id="算术运算符">算术运算符</h4><ol><li><code>+</code></li><li><code>-</code></li><li><code>*</code></li><li><code>/</code></li><li><code>%</code></li></ol><h4 id="关系运算符">关系运算符</h4><ol><li><code>&gt;</code></li><li><code>&lt;</code></li><li><code>&gt;=</code></li><li><code>&lt;=</code></li><li><code>==</code></li><li><code>!=</code></li></ol><h4 id="逻辑运算符">逻辑运算符</h4><ol><li><code>!</code></li><li><code>&amp;&amp;</code></li><li><code>||</code></li></ol><h4 id="条件运算符">条件运算符</h4><ol><li><code>?:</code></li></ol><h4 id="位运算符">位运算符</h4><ol><li><code>~</code></li><li><code>&amp;</code></li><li><code>|</code></li><li><code>^</code></li></ol><h4 id="移位运算符">移位运算符</h4><ol><li><code>&lt;&lt;</code></li><li><code>&gt;&gt;</code></li></ol><h4 id="拼接运算符">拼接运算符</h4><ol><li><code>&#123;&#125;</code></li></ol><h4 id="运算符优先级">运算符优先级</h4><div align="center"><img src="/2022/02/12/LearnVerilog-md/poiror.png"></div><h3 id="程序框架">程序框架</h3><h4 id="注释-与c语言相同">注释(与c语言相同)</h4><h4 id="关键字">关键字</h4><div align="center"><img src="/2022/02/12/LearnVerilog-md/keyWord.png"></div><h4 id="程序框架-2">程序框架</h4><p>框架例程</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> led( </span><br><span class="line">    <span class="keyword">input</span>               sys_clk  ,  <span class="comment">//系统时钟 </span></span><br><span class="line">    <span class="keyword">input</span>               sys_rst_n,  <span class="comment">//系统复位，低电平有效 </span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]  led         <span class="comment">//4位LED灯 </span></span><br><span class="line">    ); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//parameter define </span></span><br><span class="line"><span class="keyword">parameter</span>  WIDTH     = <span class="number">25</span>        ;  <span class="comment">//位宽</span></span><br><span class="line"><span class="keyword">parameter</span>  COUNT_MAX = <span class="number">25_000_000</span>;  <span class="comment">//板载50M时钟=20ns，0.5s/20ns=25000000，需要25bit </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reg define </span></span><br><span class="line"><span class="keyword">reg</span>    [WIDTH-<span class="number">1</span>:<span class="number">0</span>]  counter     ; </span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">1</span>:<span class="number">0</span>]        led_ctrl_cnt; </span><br><span class="line"></span><br><span class="line"><span class="comment">//wire define </span></span><br><span class="line"><span class="keyword">wire</span>                counter_en  ; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************************************************************************** </span></span><br><span class="line"><span class="comment">//**                                 main code </span></span><br><span class="line"><span class="comment">//*********************************************************************************** </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计数到最大值时产生高电平使能信号 </span></span><br><span class="line"><span class="keyword">assign</span>  counter_en = (counter == (COUNT_MAX - <span class="number">1&#x27;b1</span>))  ?  <span class="number">1&#x27;b1</span>  :  <span class="number">1&#x27;b0</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//用于产生0.5秒使能信号的计数器 </span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">if</span> (sys_rst_n == <span class="number">1&#x27;b0</span>) </span><br><span class="line">        counter &lt;= <span class="number">1&#x27;b0</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (counter_en) </span><br><span class="line">        counter &lt;= <span class="number">1&#x27;b0</span>; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        counter &lt;= counter + <span class="number">1&#x27;b1</span>; </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="comment">//led流水控制计数器 </span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">if</span> (sys_rst_n == <span class="number">1&#x27;b0</span>) </span><br><span class="line">        led_ctrl_cnt &lt;= <span class="number">2&#x27;b0</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (counter_en) </span><br><span class="line">        led_ctrl_cnt &lt;= led_ctrl_cnt + <span class="number">2&#x27;b1</span>; </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//通过控制IO口的高低电平实现发光二极管的亮灭 </span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">if</span> (sys_rst_n == <span class="number">1&#x27;b0</span>) </span><br><span class="line">        led &lt;= <span class="number">4&#x27;b0</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">case</span> (led_ctrl_cnt)                  </span><br><span class="line">            <span class="number">2&#x27;d0</span> : led &lt;= <span class="number">4&#x27;b0001</span>; </span><br><span class="line">            <span class="number">2&#x27;d1</span> : led &lt;= <span class="number">4&#x27;b0010</span>; </span><br><span class="line">            <span class="number">2&#x27;d2</span> : led &lt;= <span class="number">4&#x27;b0100</span>; </span><br><span class="line">            <span class="number">2&#x27;d3</span> : led &lt;= <span class="number">4&#x27;b1000</span>; </span><br><span class="line">            <span class="keyword">default</span> : ; </span><br><span class="line">        <span class="keyword">endcase</span> </span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>以下对上述代码块进行详细说明:<br></p><p>首先提出一个概念<em><strong>模块级例化语句</strong></em>，它是结构建模中最常用的方式。模块是Verilog 中基本单元的定义形式，是与外界交互的接口。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name </span><br><span class="line">#(parameter_list) <span class="comment">//参数可选</span></span><br><span class="line">(port_list) ;  <span class="comment">//端口列表、端口声明</span></span><br><span class="line">        ;<span class="comment">//Declarations_and_Statements</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>参数和变量定义</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parameter define </span></span><br><span class="line"><span class="keyword">parameter</span>  WIDTH     = <span class="number">25</span>        ;  <span class="comment">//位宽</span></span><br><span class="line"><span class="keyword">parameter</span>  COUNT_MAX = <span class="number">25_000_000</span>;  <span class="comment">//板载50M时钟=20ns，0.5s/20ns=25000000，需要25bit </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reg define </span></span><br><span class="line"><span class="keyword">reg</span>    [WIDTH-<span class="number">1</span>:<span class="number">0</span>]  counter     ; </span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">1</span>:<span class="number">0</span>]        led_ctrl_cnt; </span><br><span class="line"></span><br><span class="line"><span class="comment">//wire define </span></span><br><span class="line"><span class="keyword">wire</span>                counter_en  ; </span><br></pre></td></tr></table></figure><p>进入代码主体</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数到最大值时产生高电平使能信号 </span></span><br><span class="line"><span class="keyword">assign</span>  counter_en = (counter == (COUNT_MAX - <span class="number">1&#x27;b1</span>))  ?  <span class="number">1&#x27;b1</span>  :  <span class="number">1&#x27;b0</span>;   </span><br></pre></td></tr></table></figure><p>第一句通过条件运算符实现当计满时<code>counter_en</code>高电平，未满时低电平。以下说明<code>assign</code>：<br><br><code>assign</code>用于连续赋值语句用于为<code>wire</code>类型赋值</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>     LHS_target = RHS_expression  ；<span class="comment">//LHS必须为wire类型，RHS类型任意</span></span><br></pre></td></tr></table></figure><p><code>wire</code>类型变量也可以在声明时直接赋值，因为<code>wire</code>类型变量只可以赋值一次所以两种方式效果相同。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于产生0.5秒使能信号的计数器 </span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">if</span> (sys_rst_n == <span class="number">1&#x27;b0</span>) </span><br><span class="line">        counter &lt;= <span class="number">1&#x27;b0</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (counter_en) </span><br><span class="line">        counter &lt;= <span class="number">1&#x27;b0</span>; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        counter &lt;= counter + <span class="number">1&#x27;b1</span>; </span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure><p><code>always</code>属于过程结构语句，以下介绍过程结构语句:（引用自菜鸟教程）<br></p><ul><li>过程结构语句有 2 种，<code>initial</code> 与 <code>always</code> 语句。它们是行为级建模的 2 种基本语句。</li><li>一个模块中可以包含多个 <code>initial</code> 和 <code>always</code> 语句，但 2 种语句不能嵌套使用。</li><li>这些语句在模块间并行执行，与其在模块的前后顺序没有关系。</li><li>但是 <code>initial</code> 语句或 <code>always</code> 语句内部可以理解为是顺序执行的（非阻塞赋值除外）。</li><li>每个 <code>initial</code> 语句或 <code>always</code> 语句都会产生一个独立的控制流，执行时间都是从 0 时刻开始。</li></ul><ol><li><code>initial</code>语句<ul><li><code>initial</code> 语句从 0 时刻开始执行，只执行一次，多个 <code>initial</code> 块之间是相互独立的。</li><li>如果 <code>initial</code> 块内包含多个语句，需要使用关键字 <code>begin</code> 和 <code>end</code> 组成一个块语句。</li><li>如果 <code>initial</code> 块内只要一条语句，关键字 <code>begin</code> 和 <code>end</code> 可使用也可不使用。</li><li><code>initial</code> 理论上来讲是不可综合的，多用于初始化、信号检测等。</li></ul></li><li><code>always</code>语句<ul><li>与 initial 语句相反，always 语句是重复执行的。always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。</li></ul></li></ol><p><code>posedge</code>为positive edge的缩写即上升沿，同理<code>negedge</code>为negitive edge下降沿的缩写。这就引出了verilog的时序控制。<br></p><ol><li>时延控制<code>#delay procedural_statement</code></li><li>事件控制 一般用符号<code>@</code>来表示<ol><li>一般事件触发<ol><li>使用方法<code>always @(clk) q &lt;= d ;</code>clk只要变化就触发</li><li><code>always @(posedge clk) q &lt;= d ; </code>clk上升沿触发</li><li><code>always @(negedge clk) q &lt;= d ;</code>clk下降沿触发</li><li><code>q = @(posedge clk) d ; </code>clk上升沿将d赋值给q，不推荐写法</li></ol></li><li>命名事件触发 会用到<code>event</code>类型变量，暂时不触及</li><li>敏感列表 采用关键字<code>or</code>或<code>,</code>来连接多个能够触发的事件,如<code>always @(posedge clk or negedge rstn)q &lt;= d;</code></li></ol></li><li>边沿触发</li><li>电平触发</li></ol>]]></content>
      
      
      <categories>
          
          <category> verilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名飞控源码解析(二)---Ano_FcData数据处理</title>
      <link href="/2022/02/03/ano-2/"/>
      <url>/2022/02/03/ano-2/</url>
      
        <content type="html"><![CDATA[<h1 id="匿名飞控源码解析-二-—Ano-FcData数据处理"><a href="#匿名飞控源码解析-二-—Ano-FcData数据处理" class="headerlink" title="匿名飞控源码解析(二)—Ano_FcData数据处理"></a>匿名飞控源码解析(二)—Ano_FcData数据处理</h1><p>上次我们一起泛泛的看了主程序，这一次我们将目光重点放在<code>Ano_FcData</code></p><h2 id="从头文件入手"><a href="#从头文件入手" class="headerlink" title="从头文件入手"></a>从头文件入手</h2><p>同样我们先看头文件中的预处理指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define to prevent recursive inclusion -------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ANO_FCDATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ANO_FCDATA_H</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Exported types ------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0 </span></span><br><span class="line">;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>条件编译经典防止重复包含，后面的宏自定义了布尔值没什么可说的。<br><br><code>#include &quot;config.h&quot;</code>从用户目录下包含了<code>config.h</code>。<br></p><h3 id="细说config-h"><a href="#细说config-h" class="headerlink" title="细说config.h"></a>细说config.h</h3><p><code>config.h</code>在这个工程是一个比较特殊的头文件，因为它和其他自定义头文件不一样，它没有对应的c文件，这意味其中不会有共享函数声明<em><strong>只有共享宏定义和共享类型定义</strong></em>甚至共享变量声明也几乎不会有(我几乎从来没有在单片机工程代码中见过<code>extern</code>声明)</p><p>条件编译部分不再赘述，接下来<code>#include &quot;stm32f4xx.h&quot;</code>包含32F4基本头文件也不再多说，接下来是重点部分:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************换算******************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANGLE_TO_RADIAN 0.01745329f <span class="comment">//*0.01745 = /57.3角度转弧度</span></span></span><br><span class="line"><span class="comment">/***********************************************/</span></span><br></pre></td></tr></table></figure><p>0.017444是角度转弧度的转换因子，也即<code>3.14/180</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANO_DT_USE_NRF24l01</span></span><br></pre></td></tr></table></figure><p>上面这句定义的这个宏不知道干啥使得，不过看命名像是一个芯片的使用标志一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SP_EST_DRAG 1.0f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BARO_WIND_COMP 0.10f</span></span><br></pre></td></tr></table></figure><p>又定义了两个不知道干啥使的宏，应该是用作环境因素系数的吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GYR_ACC_FILTER 0.25f <span class="comment">//陀螺仪加速度计滤波系数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FINAL_P  0.35f  <span class="comment">//电机输出量比例系数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTOR_ESC_TYPE 1  <span class="comment">//2：某些无刷电机带刹车的电调(谨慎测试)  1：无刷电机不带刹车的电调(默认)，</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOTORSNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BAT_LOW_VOTAGE 3250    <span class="comment">//mV</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOAW_MAX_HEIGHT  450</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOW_ROLL_CONDITION 8 <span class="comment">//   0-12</span></span></span><br></pre></td></tr></table></figure><ul><li>陀螺仪加速度计滤波系数为0.25</li><li>电机输出量比例系数为0.35* 电调为不带刹车</li><li>电机总共为4个</li><li>电池低电压阈值为3250</li><li>飞行最高高度为 450</li><li>飞行状况？ 为8<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APP_ROLL_CH CH_PIT <span class="comment">//app翻滚</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ANGLE     25.0f</span></span><br><span class="line"><span class="comment">//#define MAX_ANGLE_ROL 25.0f //角度</span></span><br><span class="line"><span class="comment">//#define MAX_ANGLE_PIT 25.0f //角度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SPEED_ROL 200  <span class="comment">//角度每秒</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SPEED_PIT 200  <span class="comment">//角度每秒</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SPEED_YAW 250  <span class="comment">//角度每秒</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ROLLING_SPEED 1600  <span class="comment">//角度每秒</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SPEED 500 <span class="comment">//最大水平速度，厘米每秒 cm/s</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_Z_SPEED_UP 350 <span class="comment">//厘米每秒 cm/s</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_Z_SPEED_DW 250 <span class="comment">//厘米每秒 cm/s</span></span></span><br></pre></td></tr></table></figure></li><li>app翻转？不懂干嘛用的</li><li>最大角度为25</li><li>最大姿态角速度为200度每秒</li><li>不知道<code>MAX_SPEED_ROL</code> 和<code>MAX_ROLLING_SPEED</code> 的区别</li><li>最大水平速度为500厘米每秒</li><li>最大上升速度为350厘米每秒</li><li>最大下降速度为250厘米每秒<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EXP_XY_ACC   500 <span class="comment">//厘米每平方秒 cm/ss</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EXP_Z_ACC    600 <span class="comment">//厘米每平方秒 cm/ss</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTRL_1_INTE_LIM 250 <span class="comment">//角速度环积分限幅 ：输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANGULAR_VELOCITY_PID_INTE_D_LIM 300/FINAL_P  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_PROPORTION_X_Y 1.0f <span class="comment">//proportion</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROLL_ANGLE_KP 10.0f   <span class="comment">//翻滚角度kp</span></span></span><br></pre></td></tr></table></figure></li><li>最大水平加速度为500厘米每平方秒</li><li>最大垂直加速度为600厘米每平方秒</li><li>角速度环积分环节最大为250</li><li><code>ANGULAR_VELOCITY_PID_INTE_D_LIM</code>不知道干啥使的</li><li>水平的比例环节系数为1</li><li>翻滚角度比例系数为10<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_THR_SET    85  <span class="comment">//最大油门百分比 %</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THR_INTE_LIM_SET   70  <span class="comment">//油门积分百分比 % </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THR_INTE_LIM   THR_INTE_LIM_SET/FINAL_P  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THR_START      35  <span class="comment">//油门起调量百分比 %</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAND_ACC              500  <span class="comment">//着陆加速度检测</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAND_ACC_DELTA        300  <span class="comment">//着陆加速度变化量检测</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BARO_FIX -0                          <span class="comment">//气压速度积分修正起调值/CM厘米</span></span></span><br></pre></td></tr></table></figure></li><li>最大油门百分比为百分之85</li><li>油门积分百分比为百分之70</li><li>最小油门百分比为百分之35</li><li>着陆加速度和着陆加速度变化有什么区别</li></ul><p>出现了很多无法理解的但是不要着急，先记下来以后进一步看其他代码的时候应该可以增进理解。</p><h3 id="config-h疑问总结"><a href="#config-h疑问总结" class="headerlink" title="config.h疑问总结"></a>config.h疑问总结</h3><ol><li><code>ANGULAR_VELOCITY_PID_INTE_D_LIM</code>不知道干啥使的</li><li>不知道<code>MAX_SPEED_ROL</code> 和<code>MAX_ROLLING_SPEED</code> 的区别</li><li>着陆加速度和着陆加速度变化有什么区别</li><li><code>SP_EST_DRAG</code>和<code>BARO_WIND_COMP</code>这两个宏干啥使的</li><li>app翻转是啥</li></ol><p>沉迷电吉他，今天摸了<br><br>今天装电脑，差个散热器难顶，摸了</p><h2 id="说回ANo-FcData-h"><a href="#说回ANo-FcData-h" class="headerlink" title="说回ANo_FcData.h"></a>说回<code>ANo_FcData.h</code></h2><p>说到<code>Ano_FcData.h</code>第一眼的感觉就是怎么这么多枚举，所以我们先复习一下枚举类型吧。<br><br>枚举类型的关键字<code>enum</code>，枚举的作用与宏类似，常见使用方式为:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span> <span class="title">a</span> =</span> Mon, b = Wed, c = Sat;</span><br></pre></td></tr></table></figure><p>值得注意的是枚举的值只是一些整数，c语言允许它们与普通整数进行混合，并且编译器会将枚举变量当作整形变量进行处理。<br><br>下面开始具体看<code>Ano_FcData.h</code>的代码<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">AUTO_TAKE_OFF_NULL = <span class="number">0</span>,</span><br><span class="line">AUTO_TAKE_OFF = <span class="number">1</span>,</span><br><span class="line">AUTO_TAKE_OFF_FINISH,</span><br><span class="line">AUTO_LAND,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pwminmode_e</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">PWM = <span class="number">0</span>,</span><br><span class="line">PPM,</span><br><span class="line">SBUS,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> A_X = <span class="number">0</span>,</span><br><span class="line"> A_Y ,</span><br><span class="line"> A_Z ,</span><br><span class="line"> G_X ,</span><br><span class="line"> G_Y ,</span><br><span class="line"> G_Z ,</span><br><span class="line"> TEM ,</span><br><span class="line"> MPU_ITEMS ,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> CH_ROL = <span class="number">0</span>,</span><br><span class="line"> CH_PIT ,</span><br><span class="line"> CH_THR ,</span><br><span class="line"> CH_YAW ,</span><br><span class="line"> AUX1 ,</span><br><span class="line"> AUX2 ,</span><br><span class="line"> AUX3 ,</span><br><span class="line"> AUX4 ,</span><br><span class="line"> CH_NUM,<span class="comment">//8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">m1=<span class="number">0</span>,</span><br><span class="line">m2,</span><br><span class="line">m3,</span><br><span class="line">m4,</span><br><span class="line">m5,</span><br><span class="line">m6,</span><br><span class="line">m7,</span><br><span class="line">m8,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">MPU_6050_0 = <span class="number">0</span>,</span><br><span class="line">MPU_6050_1,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">X = <span class="number">0</span>,</span><br><span class="line">Y = <span class="number">1</span>,</span><br><span class="line">Z = <span class="number">2</span>,</span><br><span class="line">VEC_XYZ,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ROL = <span class="number">0</span>,</span><br><span class="line">PIT = <span class="number">1</span>,</span><br><span class="line">YAW = <span class="number">2</span>,</span><br><span class="line">VEC_RPY,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">KP = <span class="number">0</span>,</span><br><span class="line">KI = <span class="number">1</span>,</span><br><span class="line">KD = <span class="number">2</span>,</span><br><span class="line">PID,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> _<span class="title">power_alarm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">HIGH_POWER = <span class="number">0</span>,</span><br><span class="line">HALF_POWER,</span><br><span class="line">LOW_POWER ,</span><br><span class="line">LOWEST_POWER, </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> _<span class="title">flight_mode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ATT_STAB = <span class="number">0</span>,<span class="comment">//Attitude stabilization</span></span><br><span class="line">LOC_HOLD,</span><br><span class="line">RETURN_HOME,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//thr_mode</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  THR_MANUAL = <span class="number">0</span>,</span><br><span class="line">THR_AUTO,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> _<span class="title">power_alarm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">HIGH_POWER = <span class="number">0</span>,</span><br><span class="line">HALF_POWER,</span><br><span class="line">LOW_POWER ,</span><br><span class="line">LOWEST_POWER, </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>能源警告结构体，这个结构体就非常明确了，不用再多解释。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> _<span class="title">flight_mode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ATT_STAB = <span class="number">0</span>,<span class="comment">//Attitude stabilization</span></span><br><span class="line">LOC_HOLD,</span><br><span class="line">RETURN_HOME,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>飞行模式结构体，分为三种模式:<br></p><ol><li><code>ATT_STAB = 0</code>稳定姿态模式</li><li><code>LOC_HOLD</code>保持模式？</li><li><code>RETURN_HOME</code>返回模式</li></ol><p>对于以上的各种枚举类型不再赘述，就如前文所讲就是宏定义的平替版，大概率会被用来作模式选择或者FLAG等功能。<br><br>接下来看剩下的结构体类型定义部分:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u8 first_f;</span><br><span class="line"><span class="keyword">float</span> acc_offset[VEC_XYZ];</span><br><span class="line"><span class="keyword">float</span> gyro_offset[VEC_XYZ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> surface_vec[VEC_XYZ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> mag_offset[VEC_XYZ];</span><br><span class="line"><span class="keyword">float</span> mag_gain[VEC_XYZ];</span><br><span class="line"></span><br><span class="line">&#125; _save_st ;</span><br><span class="line"><span class="keyword">extern</span> _save_st save;</span><br></pre></td></tr></table></figure><p>这里定义了一个结构体类型<code>_save_st</code>，然后又紧接着声明了一<code>_save_st</code>类型的外部变量<code>save</code>。结构中包含六个元素分别为:<br></p><ul><li><code>u8 first_f;</code></li><li><code>float acc_offset[VEC_XYZ];</code></li><li><code>float gyro_offset[VEC_XYZ];</code></li><li><code>float surface_vec[VEC_XYZ];</code></li><li><code>float mag_offset[VEC_XYZ];</code></li><li><code>float mag_gain[VEC_XYZ];</code></li></ul><p>其中<code>VEC_XYZ</code>定义在:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">X = <span class="number">0</span>,</span><br><span class="line">Y = <span class="number">1</span>,</span><br><span class="line">Z = <span class="number">2</span>,</span><br><span class="line">VEC_XYZ,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如我前文所说<code>VEC_XYZ</code>完全就是被当成宏用的，表示整数4.所以以上结构中的数组元素为4个元素的浮点型数组。不过结构中的各个元素暂时不知道怎么用的只能暂时通过名字猜测其功能，这里不再在此浪费时间<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//基本状态/传感器</span></span><br><span class="line">u8 start_ok;</span><br><span class="line">u8 sensor_imu_ok;</span><br><span class="line">u8 mems_temperature_ok;</span><br><span class="line"></span><br><span class="line">u8 motionless;</span><br><span class="line">u8 power_state;</span><br><span class="line">u8 wifi_ch_en;</span><br><span class="line">u8 chn_failsafe;</span><br><span class="line">u8 rc_loss;</span><br><span class="line">u8 rc_loss_back_home;</span><br><span class="line">u8 gps_ok;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//控制状态</span></span><br><span class="line">u8 manual_locked;</span><br><span class="line">u8 unlock_err;</span><br><span class="line">u8 unlock_cmd;</span><br><span class="line">u8 unlock_sta;<span class="comment">//unlocked</span></span><br><span class="line">u8 thr_low;</span><br><span class="line">u8 locking;</span><br><span class="line">u8 taking_off; <span class="comment">//起飞</span></span><br><span class="line">u8 set_yaw;</span><br><span class="line">u8 ct_loc_hold;</span><br><span class="line">u8 ct_alt_hold;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//飞行状态</span></span><br><span class="line">u8 flying;</span><br><span class="line">u8 auto_take_off_land;</span><br><span class="line">u8 home_location_ok;</span><br><span class="line">u8 speed_mode;</span><br><span class="line">u8 thr_mode;</span><br><span class="line">u8 flight_mode;</span><br><span class="line">u8 flight_mode2;</span><br><span class="line">u8 gps_mode_en;</span><br><span class="line">u8 motor_preparation;</span><br><span class="line">u8 locked_rotor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;_flag;</span><br><span class="line"><span class="keyword">extern</span> _flag flag;</span><br></pre></td></tr></table></figure><p><code>_flag</code>结构类型为飞行控制过程标识位的大集合，命名方式非常明确，源码的注释也很具体不再赘述。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">float</span> vel_limit_xy;</span><br><span class="line"><span class="keyword">float</span> vel_limit_z_p;</span><br><span class="line"><span class="keyword">float</span> vel_limit_z_n;</span><br><span class="line"><span class="keyword">float</span> yaw_pal_limit;</span><br><span class="line">&#125;_fc_sta_var_st; <span class="comment">//state variable</span></span><br><span class="line"><span class="keyword">extern</span> _fc_sta_var_st fc_stv;</span><br></pre></td></tr></table></figure><p><code>_fc_sta_var_st</code>从命名来看是飞行控制状态变量结构体，具体功能并不明白。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u8 sonar_on;</span><br><span class="line">u8 tof_on;</span><br><span class="line">u8 of_flow_on;</span><br><span class="line">u8 of_tof_on;</span><br><span class="line">u8 baro_on;</span><br><span class="line">u8 gps_on;</span><br><span class="line">u8 uwb_on;</span><br><span class="line">u8 opmv_on;</span><br><span class="line"></span><br><span class="line">&#125;_switch_st;</span><br><span class="line"><span class="keyword">extern</span> _switch_st switchs;</span><br></pre></td></tr></table></figure><p><code>_switch_st</code>从命名来看是开关结构体，其中的元素应该起到开关作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u8 gyro_ok;</span><br><span class="line">u8 acc_ok;</span><br><span class="line">u8 mag_ok;</span><br><span class="line">u8 baro_ok;</span><br><span class="line">u8 gps_ok;</span><br><span class="line">u8 sonar_ok;</span><br><span class="line">u8 tof_ok;</span><br><span class="line">u8 of_ok;</span><br><span class="line">u8 of_df_ok;</span><br><span class="line"></span><br><span class="line">&#125; _sensor_hd_check_st; <span class="comment">//Hardware</span></span><br><span class="line"><span class="keyword">extern</span> _sensor_hd_check_st sens_hd_check;</span><br></pre></td></tr></table></figure><p><code>_sensor_hd_check_st</code>从命名来看是传感器硬件检测结构体，其中的元素应该是用来表示传感器情况的。<br><br>最后声明了两个<code>Ano_FcData.c</code>中的函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_save</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Para_Data_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="细说Ano-FcData-c"><a href="#细说Ano-FcData-c" class="headerlink" title="细说Ano_FcData.c"></a>细说<code>Ano_FcData.c</code></h2><h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_FcData.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_Parameter.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>首先是前面说了半天的<code>Ano_FcData.h</code>，其次是<code>Ano_Parameter.h</code>留到下次说。<br></p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_switch_st switchs;</span><br><span class="line"> _save_st save;</span><br><span class="line">_flag flag;</span><br><span class="line">_fc_sta_var_st fc_stv;</span><br><span class="line">_sensor_hd_check_st sens_hd_check;</span><br></pre></td></tr></table></figure><p>还记得<code>Ano_FcData.h</code>中结构体类型定义后紧跟着的外部变量声明吗，这就是这些变量定义(也就是为其分配内存)的地方。</p><h3 id="函数定义部分"><a href="#函数定义部分" class="headerlink" title="函数定义部分"></a>函数定义部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_save</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">para_sta.save_en = !flag.unlock_sta;</span><br><span class="line">para_sta.save_trig = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Para_Data_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Ano_Parame_Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>data_save(void)</code>从命名来看是用作数据保存，无输入也无输出。<br><br>其中<code>para_sta</code>是<code>Ano_Parameter.c</code>中定义的<code>_parameter_state_st</code>类型结构体变量，<code>_parameter_state_st</code>类型结构体是<code>Ano_Parameter.h</code>中定义的结构体类型用于保存各种参数的状态，其中从命名来看一个用于使能一个用于触发，具体的我们放到下次再说.<br><br><code>Para_Data_Init()</code>从命名来看用于参数数据的初始化，无输入也无输出。<br><br><code>Ano_Parame_Read()</code>定义在<code>Ano_Parameter.c</code>中用于读取参数且其中包含了参数初始化部分，这里就是利用这一部分来做参数初始化。</p><p>OK!现在<code>Ano_FcData</code>就说的差不多了，其中由于阅读进程的限制当然有很多看不懂的地方，但其实有很多就算看不懂也能猜个八九不离十，将看不懂的地方记录下来就好不用过于纠结，随着代码阅读进度一定是可以看懂的。好了，下次我们一起看<code>Ano_Parameter</code>.</p>]]></content>
      
      
      <categories>
          
          <category> 飞控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名飞控源码解析(一)---主程序</title>
      <link href="/2022/02/03/ano/"/>
      <url>/2022/02/03/ano/</url>
      
        <content type="html"><![CDATA[<h1 id="匿名飞控源码解析-一-—主程序"><a href="#匿名飞控源码解析-一-—主程序" class="headerlink" title="匿名飞控源码解析(一)—主程序"></a>匿名飞控源码解析(一)—主程序</h1><p>对于这个飞控的研究始于我本科时期的毕业设计，代码上的注释几乎都是由我当时书写，最近准备北航的研究生复试听闻老师们最爱问关于毕业设计的问题，故旧事重提，重新研究一下匿名飞控。<br><br>回想当时的研究，要是要我提出一个匿名飞控的特点即和其他飞控的不同之处就是没有采用硬件中断来做时分复用，而是<em><strong>采用简单的延时程序来做的时分复用</strong></em>，这使得其代码难度降低，不过感觉也有利有弊，长时间不使用定时器中断搞我的现在都有点忘了，不过这些硬件的调用就等到之后研究全权老师的rfly或者我的另一个平衡自行车项目的时候再复健吧。</p><h2 id="从主程序入手"><a href="#从主程序入手" class="headerlink" title="从主程序入手"></a>从主程序入手</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;include.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_FcData.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  USE_FULL_ASSERT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert_failed</span><span class="params">(<span class="keyword">uint8_t</span>* file, <span class="keyword">uint32_t</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当系统出错后，会进入这个死循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//=======================================================================================</span></span><br><span class="line"><span class="comment">//=======================================================================================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">flag.start_ok = All_Init();<span class="comment">//进行所有设备的初始化，并将初始化结果保存</span></span><br><span class="line">Scheduler_Setup();<span class="comment">//调度器初始化，系统为裸奔，这里人工做了一个时分调度器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Scheduler_Run();<span class="comment">//运行任务调度器，所有系统功能，除了中断服务函数，都在任务调度器内完成</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-c主程序分析"><a href="#main-c主程序分析" class="headerlink" title="main.c主程序分析"></a><code>main.c</code>主程序分析<br></h2><h3 id="预处理指令部分"><a href="#预处理指令部分" class="headerlink" title="预处理指令部分"></a>预处理指令部分</h3><p>第一条代码<code>#include &quot;include.h&quot;</code>主程序包含<code>include.h</code>头文件，接下来分部分分析该文件.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INCLUDE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INCLUDE_H_</span></span><br><span class="line">;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>条件编译的经典格式,防止重复包含头文件。</p><hr><p>接下来是头文件的包含，包括硬件驱动程序头文件(一般文件名以DRV开头)，各类数据处理控制算法等程序头文件(一般以Ano开头)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &quot;stm32f4xx.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_FcData.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_Scheduler.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BSP_Init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_DT.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_Parameter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Ano_USB.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Drv_time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Drv_pwm_in.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Drv_usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Drv_Gps.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>其中<code>Ano_FcData.h</code>为飞控数据处理的头文件，<code>Ano_Scheduler.h</code>为时分复用系统的头文件，’BSP_Init.h’为飞控初始化程序头文件，’Ano_DT.h’为飞控数据传输程序头文件，<code>Ano_Parameter.h</code>为控制参数配置头文件，<code>Ano_USB.h</code>为USB通信相关头文件。</p><p><code>Drv_time.h</code>为时钟驱动头文件<code>Drv_pwm_in.h</code>为硬件PWM驱动头文件<code>Drv_usart.h</code>为USART通信驱动头文件<code>Drv_Gps.h</code>为GPS驱动头文件。</p><p>以上仅仅是让自己脑子有个大致的印象，以后深入到源码中还会细品各程序。不过在此我还想提醒一下自己包含这么多头文件有什么作用，引用一下&lt;&lt;C程序设计现代方法&gt;&gt;上的目录:<br></p><ul><li>共享宏定义和类型定义</li><li>共享函数原型</li><li>共享变量声明</li></ul><hr><p>接下来是第二条代码<code>#include &quot;Ano_FcData.h&quot;</code>在主程序中包含<code>Ano_FcData.h</code>但是讲道理这个在上一条中已经包含过虽然有条件编译并不会有什么问题，但是其实我认为是多此一举的。由于现在是在分析主程序就并不在本篇中对其他文件的细节进行解读了。</p><h3 id="条件编译部分"><a href="#条件编译部分" class="headerlink" title="条件编译部分"></a>条件编译部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  USE_FULL_ASSERT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert_failed</span><span class="params">(<span class="keyword">uint8_t</span>* file, <span class="keyword">uint32_t</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当系统出错后，会进入这个死循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>由于这部分内容后面不会再涉及并且并不困难故在此处说一下，转到定义处代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_FULL_ASSERT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exported macro ------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  USE_FULL_ASSERT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  The assert_param macro is used for function&#x27;s parameters check.</span></span><br><span class="line"><span class="comment">  * @param  expr: If expr is false, it calls assert_failed function</span></span><br><span class="line"><span class="comment">  *   which reports the name of the source file and the source</span></span><br><span class="line"><span class="comment">  *   line number of the call that failed.</span></span><br><span class="line"><span class="comment">  *   If expr is true, it returns no value.</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))</span></span><br><span class="line"><span class="comment">/* Exported functions ------------------------------------------------------- */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">assert_failed</span><span class="params">(<span class="keyword">uint8_t</span>* file, <span class="keyword">uint32_t</span> line)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> assert_param(expr) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_FULL_ASSERT */</span></span></span><br></pre></td></tr></table></figure><p>宏<code>USE_FULL_ASSERT</code>被定义为常数1，这意味着一旦<code>USE_FULL_ASSERT</code>被定义就会进入到条件编译中，条件编译内容为一个带参数的宏。此处引用一下&lt;&lt;C程序设计现代方法&gt;&gt;上对于带参数的宏的介绍:<br></p><blockquote><p>格式为: #define 标识符(y1,y2,…,yn) 替换列表(x1,x2,…,xn)<br><br>注意:<br></p><ul><li>宏的名字和左括号之间必须没有空格，例如一定是yz_K(_yzk)指的是下划线之间部分无空格</li><li>宏的参数可以在替换列表中根据需要任意引用</li><li>一定注意要多使用括号不然傻瓜替换会治好你的低血压</li></ul></blockquote><p><code>assert_param()</code>此处被封装为一个函数，函数名直译为参数判断，@brief:函数用于函数参数检查，@param:如果参数expr为0调用<code>assert_failed()</code>，这个函数会报道导致失败的文件名和行数；如果expr为1则返回空。并且还会在主函数中定义<code>assert_failed()</code>为死循环。<br><br>而若<code>USE_FULL_ASSERT</code>未被定义则<code>#define assert_param(expr) ((void)0)</code>即返回空值。<br><br>综上，条件编译部分的经典条件编译语句我认为可以去掉而毫无影响，主体部分定义了一个死循环使得当系统出错时进入死循环仅此而已。</p><h3 id="主函数部分"><a href="#主函数部分" class="headerlink" title="主函数部分"></a>主函数部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">flag.start_ok = All_Init();<span class="comment">//进行所有设备的初始化，并将初始化结果保存</span></span><br><span class="line">Scheduler_Setup();<span class="comment">//调度器初始化，系统为裸奔，这里人工做了一个时分调度器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Scheduler_Run();<span class="comment">//运行任务调度器，所有系统功能，除了中断服务函数，都在任务调度器内完成</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数中各函数作用都在当年程序注释中注明，以下复制粘贴一下:<br></p><ul><li><code>flag.start_ok = All_Init();</code>进行所有设备的初始化，并将初始化结果保存</li><li><code>Scheduler_Setup();</code>进调度器初始化，系统为裸奔，这里人工做了一个时分调度器</li><li><code>Scheduler_Run();</code>运行任务调度器，所有系统功能，除了中断服务函数，都在任务调度器内完成</li></ul><p>OK!主程序就看到这儿了，下次和兄弟们一起看<code>Ano_FcData.h</code>和<code>Ano_FcData.c</code>中的数据处理是如何进行的!</p>]]></content>
      
      
      <categories>
          
          <category> 飞控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建备忘录</title>
      <link href="/2022/01/31/hexoLearn/"/>
      <url>/2022/01/31/hexoLearn/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><ul><li><code>hexo s</code>在本地服务器预览一般为<a href="https://localhost:4000/">https://localhost:4000</a><br></li><li><code>hexo n &quot;文件名&quot;</code>新建博文<br></li><li><code>hexo g</code>生成<br></li><li><code>hexo d</code>部署到github或者gitee设置方式见于_config.yml文档<br></li><li><code>hexo clean</code>清理</li></ul><h2 id="hexo主题更换"><a href="#hexo主题更换" class="headerlink" title="hexo主题更换"></a>hexo主题更换</h2><p>在相应github仓库下找到教程一般在blog目录下使用<code>clone</code>指令然后在_config.yml文件中修改theme后名称为相应文件夹名称.</p><h2 id="数学公式采用KaTeX"><a href="#数学公式采用KaTeX" class="headerlink" title="数学公式采用KaTeX"></a>数学公式采用KaTeX</h2>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/31/hello-world/"/>
      <url>/2022/01/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
